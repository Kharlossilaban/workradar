package services

import (
	"context"
	"fmt"
	"log"
	"net"
	"net/http"
	"regexp"
	"strings"
	"sync"
	"time"

	"github.com/workradar/server/internal/database"
	"github.com/workradar/server/internal/models"
	"gorm.io/gorm"
)

// VulnerabilityType represents types of vulnerabilities
type VulnerabilityType string

const (
	VulnSQLInjection      VulnerabilityType = "SQL_INJECTION"
	VulnXSS               VulnerabilityType = "XSS"
	VulnBruteForce        VulnerabilityType = "BRUTE_FORCE"
	VulnWeakPassword      VulnerabilityType = "WEAK_PASSWORD"
	VulnSessionHijacking  VulnerabilityType = "SESSION_HIJACKING"
	VulnCSRF              VulnerabilityType = "CSRF"
	VulnInsecureConfig    VulnerabilityType = "INSECURE_CONFIG"
	VulnDataExposure      VulnerabilityType = "DATA_EXPOSURE"
	VulnBrokenAuth        VulnerabilityType = "BROKEN_AUTH"
	VulnMissingEncryption VulnerabilityType = "MISSING_ENCRYPTION"
	VulnOutdatedDeps      VulnerabilityType = "OUTDATED_DEPS"
	VulnOpenPorts         VulnerabilityType = "OPEN_PORTS"
)

// VulnerabilitySeverity represents vulnerability severity levels
type VulnerabilitySeverity string

const (
	VulnSeverityInfo     VulnerabilitySeverity = "INFO"
	VulnSeverityLow      VulnerabilitySeverity = "LOW"
	VulnSeverityMedium   VulnerabilitySeverity = "MEDIUM"
	VulnSeverityHigh     VulnerabilitySeverity = "HIGH"
	VulnSeverityCritical VulnerabilitySeverity = "CRITICAL"
)

// Vulnerability represents a detected vulnerability
type Vulnerability struct {
	ID          string                `json:"id"`
	Type        VulnerabilityType     `json:"type"`
	Severity    VulnerabilitySeverity `json:"severity"`
	Title       string                `json:"title"`
	Description string                `json:"description"`
	Evidence    string                `json:"evidence,omitempty"`
	Remediation string                `json:"remediation"`
	CVSS        float64               `json:"cvss,omitempty"` // Common Vulnerability Scoring System
	References  []string              `json:"references,omitempty"`
	DetectedAt  time.Time             `json:"detected_at"`
	Status      string                `json:"status"` // OPEN, IN_PROGRESS, RESOLVED, FALSE_POSITIVE
}

// VulnerabilityScanResult represents scan results
type VulnerabilityScanResult struct {
	ID                 string          `json:"id"`
	StartedAt          time.Time       `json:"started_at"`
	CompletedAt        time.Time       `json:"completed_at"`
	Duration           string          `json:"duration"`
	ScanType           string          `json:"scan_type"` // QUICK, FULL, TARGETED
	Vulnerabilities    []Vulnerability `json:"vulnerabilities"`
	Summary            VulnSummary     `json:"summary"`
	RiskScore          int             `json:"risk_score"` // 0-100
	RiskLevel          string          `json:"risk_level"` // LOW, MEDIUM, HIGH, CRITICAL
	ScannedComponents  []string        `json:"scanned_components"`
	RecommendedActions []string        `json:"recommended_actions"`
}

// VulnSummary provides vulnerability summary
type VulnSummary struct {
	TotalVulnerabilities int `json:"total_vulnerabilities"`
	CriticalCount        int `json:"critical_count"`
	HighCount            int `json:"high_count"`
	MediumCount          int `json:"medium_count"`
	LowCount             int `json:"low_count"`
	InfoCount            int `json:"info_count"`
}

// SQLInjectionPattern represents SQL injection detection patterns
var sqlInjectionPatterns = []string{
	`(?i)(\%27)|(\')|(\-\-)|(\%23)|(#)`,
	`(?i)((\%3D)|(=))[^\n]*((\%27)|(\')|(\-\-)|(\%3B)|(;))`,
	`(?i)\w*((\%27)|(\'))((\%6F)|o|(\%4F))((\%72)|r|(\%52))`,
	`(?i)((\%27)|(\'))union`,
	`(?i)((\%27)|(\'))\s*select`,
	`(?i)((\%27)|(\'))\s*insert`,
	`(?i)((\%27)|(\'))\s*update`,
	`(?i)((\%27)|(\'))\s*delete`,
	`(?i)((\%27)|(\'))\s*drop`,
	`(?i)exec(\s|\+)+(s|x)p\w+`,
}

// XSSPatterns represents XSS detection patterns
var xssPatterns = []string{
	`(?i)<script[^>]*>[\s\S]*?</script>`,
	`(?i)<img[^>]+onerror\s*=`,
	`(?i)<[^>]+on\w+\s*=`,
	`(?i)javascript:`,
	`(?i)vbscript:`,
	`(?i)<iframe`,
	`(?i)<object`,
	`(?i)<embed`,
	`(?i)<svg[^>]+onload`,
}

// VulnerabilityScannerService handles vulnerability scanning
type VulnerabilityScannerService struct {
	db              *gorm.DB
	mu              sync.RWMutex
	lastScan        *VulnerabilityScanResult
	isScanning      bool
	sqlPatterns     []*regexp.Regexp
	xssPatterns     []*regexp.Regexp
	schedulerCtx    context.Context
	schedulerCancel context.CancelFunc
}

var (
	vulnScannerService     *VulnerabilityScannerService
	vulnScannerServiceOnce sync.Once
)

// GetVulnerabilityScannerService returns singleton vulnerability scanner
func GetVulnerabilityScannerService() *VulnerabilityScannerService {
	vulnScannerServiceOnce.Do(func() {
		vulnScannerService = &VulnerabilityScannerService{
			db: database.DB,
		}
		vulnScannerService.compilePatterns()
	})
	return vulnScannerService
}

// NewVulnerabilityScannerService creates a new vulnerability scanner
func NewVulnerabilityScannerService(db *gorm.DB) *VulnerabilityScannerService {
	service := &VulnerabilityScannerService{
		db: db,
	}
	service.compilePatterns()
	return service
}

// compilePatterns pre-compiles regex patterns
func (s *VulnerabilityScannerService) compilePatterns() {
	s.sqlPatterns = make([]*regexp.Regexp, 0)
	for _, pattern := range sqlInjectionPatterns {
		if re, err := regexp.Compile(pattern); err == nil {
			s.sqlPatterns = append(s.sqlPatterns, re)
		}
	}

	s.xssPatterns = make([]*regexp.Regexp, 0)
	for _, pattern := range xssPatterns {
		if re, err := regexp.Compile(pattern); err == nil {
			s.xssPatterns = append(s.xssPatterns, re)
		}
	}
}

// RunQuickScan performs a quick vulnerability scan
func (s *VulnerabilityScannerService) RunQuickScan() (*VulnerabilityScanResult, error) {
	return s.runScan("QUICK", []string{
		"authentication",
		"encryption",
		"security_events",
	})
}

// RunFullScan performs a comprehensive vulnerability scan
func (s *VulnerabilityScannerService) RunFullScan() (*VulnerabilityScanResult, error) {
	return s.runScan("FULL", []string{
		"authentication",
		"encryption",
		"security_events",
		"database",
		"api_endpoints",
		"configuration",
		"network",
	})
}

// runScan executes the vulnerability scan
func (s *VulnerabilityScannerService) runScan(scanType string, components []string) (*VulnerabilityScanResult, error) {
	s.mu.Lock()
	if s.isScanning {
		s.mu.Unlock()
		return nil, fmt.Errorf("scan already in progress")
	}
	s.isScanning = true
	s.mu.Unlock()

	defer func() {
		s.mu.Lock()
		s.isScanning = false
		s.mu.Unlock()
	}()

	startTime := time.Now()
	result := &VulnerabilityScanResult{
		ID:                fmt.Sprintf("scan_%d", startTime.Unix()),
		StartedAt:         startTime,
		ScanType:          scanType,
		Vulnerabilities:   make([]Vulnerability, 0),
		ScannedComponents: components,
	}

	// Run scans for each component
	for _, component := range components {
		vulns := s.scanComponent(component)
		result.Vulnerabilities = append(result.Vulnerabilities, vulns...)
	}

	// Calculate summary
	result.Summary = s.calculateSummary(result.Vulnerabilities)
	result.RiskScore = s.calculateRiskScore(result)
	result.RiskLevel = s.determineRiskLevel(result.RiskScore)
	result.RecommendedActions = s.generateRecommendations(result)
	result.CompletedAt = time.Now()
	result.Duration = result.CompletedAt.Sub(startTime).String()

	// Store last scan
	s.mu.Lock()
	s.lastScan = result
	s.mu.Unlock()

	log.Printf("üîí Vulnerability Scan Complete: RiskScore=%d RiskLevel=%s Vulnerabilities=%d",
		result.RiskScore, result.RiskLevel, len(result.Vulnerabilities))

	return result, nil
}

// scanComponent scans a specific component
func (s *VulnerabilityScannerService) scanComponent(component string) []Vulnerability {
	vulns := make([]Vulnerability, 0)

	switch component {
	case "authentication":
		vulns = append(vulns, s.scanAuthentication()...)
	case "encryption":
		vulns = append(vulns, s.scanEncryption()...)
	case "security_events":
		vulns = append(vulns, s.scanSecurityEvents()...)
	case "database":
		vulns = append(vulns, s.scanDatabase()...)
	case "api_endpoints":
		vulns = append(vulns, s.scanAPIEndpoints()...)
	case "configuration":
		vulns = append(vulns, s.scanConfiguration()...)
	case "network":
		vulns = append(vulns, s.scanNetwork()...)
	}

	return vulns
}

// scanAuthentication scans for authentication vulnerabilities
func (s *VulnerabilityScannerService) scanAuthentication() []Vulnerability {
	vulns := make([]Vulnerability, 0)

	// Check for accounts without MFA (admin/vip)
	var count int64
	s.db.Model(&models.User{}).
		Where("user_type IN ? AND mfa_enabled = ? AND deleted_at IS NULL", []string{"admin", "vip"}, false).
		Count(&count)

	if count > 0 {
		vulns = append(vulns, Vulnerability{
			ID:          fmt.Sprintf("AUTH_%d", time.Now().UnixNano()),
			Type:        VulnBrokenAuth,
			Severity:    VulnSeverityHigh,
			Title:       "Privileged Accounts Without MFA",
			Description: fmt.Sprintf("%d admin/VIP accounts do not have MFA enabled", count),
			Remediation: "Enforce MFA for all privileged accounts",
			CVSS:        7.5,
			References:  []string{"CWE-287", "OWASP A7:2017"},
			DetectedAt:  time.Now(),
			Status:      "OPEN",
		})
	}

	// Check for locked accounts
	s.db.Model(&models.User{}).
		Where("locked_until > ? AND deleted_at IS NULL", time.Now()).
		Count(&count)

	if count > 5 {
		vulns = append(vulns, Vulnerability{
			ID:          fmt.Sprintf("AUTH_%d", time.Now().UnixNano()),
			Type:        VulnBruteForce,
			Severity:    VulnSeverityMedium,
			Title:       "Multiple Locked Accounts",
			Description: fmt.Sprintf("%d accounts are currently locked, indicating potential brute force attacks", count),
			Remediation: "Review locked accounts and strengthen rate limiting",
			CVSS:        5.3,
			References:  []string{"CWE-307"},
			DetectedAt:  time.Now(),
			Status:      "OPEN",
		})
	}

	return vulns
}

// scanEncryption scans for encryption vulnerabilities
func (s *VulnerabilityScannerService) scanEncryption() []Vulnerability {
	vulns := make([]Vulnerability, 0)

	// Check encryption service
	encService := GetEncryptionService()
	if !encService.IsEnabled {
		vulns = append(vulns, Vulnerability{
			ID:          fmt.Sprintf("ENC_%d", time.Now().UnixNano()),
			Type:        VulnMissingEncryption,
			Severity:    VulnSeverityCritical,
			Title:       "Field-Level Encryption Disabled",
			Description: "Sensitive data is not encrypted at rest",
			Remediation: "Configure ENCRYPTION_KEY environment variable",
			CVSS:        9.1,
			References:  []string{"CWE-311", "OWASP A3:2017"},
			DetectedAt:  time.Now(),
			Status:      "OPEN",
		})
	}

	// Check for unencrypted sensitive data
	var unencryptedCount int64
	s.db.Model(&models.User{}).
		Where("encrypted_email IS NULL OR encrypted_email = ''").
		Where("email IS NOT NULL AND email != ''").
		Where("deleted_at IS NULL").
		Count(&unencryptedCount)

	if unencryptedCount > 0 {
		vulns = append(vulns, Vulnerability{
			ID:          fmt.Sprintf("ENC_%d", time.Now().UnixNano()),
			Type:        VulnDataExposure,
			Severity:    VulnSeverityHigh,
			Title:       "Unencrypted PII Data",
			Description: fmt.Sprintf("%d user records have unencrypted email addresses", unencryptedCount),
			Remediation: "Run data migration to encrypt existing PII data",
			CVSS:        7.5,
			References:  []string{"CWE-312", "GDPR Art. 32"},
			DetectedAt:  time.Now(),
			Status:      "OPEN",
		})
	}

	return vulns
}

// scanSecurityEvents scans recent security events
func (s *VulnerabilityScannerService) scanSecurityEvents() []Vulnerability {
	vulns := make([]Vulnerability, 0)
	cutoffTime := time.Now().Add(-24 * time.Hour)

	// Check for SQL injection attempts
	var sqlAttempts int64
	s.db.Model(&models.SecurityEvent{}).
		Where("event_type = ? AND created_at >= ?", "SQL_INJECTION_ATTEMPT", cutoffTime).
		Count(&sqlAttempts)

	if sqlAttempts > 0 {
		vulns = append(vulns, Vulnerability{
			ID:          fmt.Sprintf("SEC_%d", time.Now().UnixNano()),
			Type:        VulnSQLInjection,
			Severity:    VulnSeverityHigh,
			Title:       "SQL Injection Attempts Detected",
			Description: fmt.Sprintf("%d SQL injection attempts detected in the last 24 hours", sqlAttempts),
			Remediation: "Review and block malicious IPs, verify parameterized queries",
			CVSS:        8.6,
			References:  []string{"CWE-89", "OWASP A1:2017"},
			DetectedAt:  time.Now(),
			Status:      "OPEN",
		})
	}

	// Check for XSS attempts
	var xssAttempts int64
	s.db.Model(&models.SecurityEvent{}).
		Where("event_type = ? AND created_at >= ?", "XSS_ATTEMPT", cutoffTime).
		Count(&xssAttempts)

	if xssAttempts > 0 {
		vulns = append(vulns, Vulnerability{
			ID:          fmt.Sprintf("SEC_%d", time.Now().UnixNano()),
			Type:        VulnXSS,
			Severity:    VulnSeverityMedium,
			Title:       "XSS Attempts Detected",
			Description: fmt.Sprintf("%d XSS attempts detected in the last 24 hours", xssAttempts),
			Remediation: "Review input validation and output encoding",
			CVSS:        6.1,
			References:  []string{"CWE-79", "OWASP A7:2017"},
			DetectedAt:  time.Now(),
			Status:      "OPEN",
		})
	}

	return vulns
}

// scanDatabase scans for database vulnerabilities
func (s *VulnerabilityScannerService) scanDatabase() []Vulnerability {
	vulns := make([]Vulnerability, 0)

	// Check database connection pool health
	stats := database.GetDBStatsStruct()
	if stats != nil && stats.MaxOpenConnections > 0 && stats.OpenConnections > stats.MaxOpenConnections*90/100 {
		vulns = append(vulns, Vulnerability{
			ID:          fmt.Sprintf("DB_%d", time.Now().UnixNano()),
			Type:        VulnInsecureConfig,
			Severity:    VulnSeverityMedium,
			Title:       "Database Connection Pool Near Capacity",
			Description: fmt.Sprintf("Connection pool at %d%% capacity", stats.OpenConnections*100/stats.MaxOpenConnections),
			Remediation: "Increase connection pool size or optimize query performance",
			CVSS:        4.3,
			DetectedAt:  time.Now(),
			Status:      "OPEN",
		})
	}

	return vulns
}

// scanAPIEndpoints scans for API vulnerabilities
func (s *VulnerabilityScannerService) scanAPIEndpoints() []Vulnerability {
	vulns := make([]Vulnerability, 0)

	// Check for blocked IPs indicating attacks
	var blockedCount int64
	s.db.Model(&models.BlockedIP{}).
		Where("blocked_until > ? OR is_permanent = ?", time.Now(), true).
		Count(&blockedCount)

	if blockedCount > 20 {
		vulns = append(vulns, Vulnerability{
			ID:          fmt.Sprintf("API_%d", time.Now().UnixNano()),
			Type:        VulnBruteForce,
			Severity:    VulnSeverityMedium,
			Title:       "High Volume of Blocked IPs",
			Description: fmt.Sprintf("%d IPs are currently blocked, indicating sustained attack attempts", blockedCount),
			Remediation: "Consider implementing additional WAF rules or DDoS protection",
			CVSS:        5.3,
			DetectedAt:  time.Now(),
			Status:      "OPEN",
		})
	}

	return vulns
}

// scanConfiguration scans for configuration vulnerabilities
func (s *VulnerabilityScannerService) scanConfiguration() []Vulnerability {
	vulns := make([]Vulnerability, 0)

	// Check key manager
	keyMgr := GetKeyManager()
	if keyMgr != nil {
		// Check for missing critical keys
		if _, err := keyMgr.GetKey(string(KeyTypeJWT)); err != nil {
			vulns = append(vulns, Vulnerability{
				ID:          fmt.Sprintf("CFG_%d", time.Now().UnixNano()),
				Type:        VulnInsecureConfig,
				Severity:    VulnSeverityCritical,
				Title:       "Missing JWT Secret Key",
				Description: "JWT_SECRET is not configured properly",
				Remediation: "Set JWT_SECRET environment variable with a strong random value",
				CVSS:        9.8,
				References:  []string{"CWE-321"},
				DetectedAt:  time.Now(),
				Status:      "OPEN",
			})
		}
	}

	return vulns
}

// scanNetwork scans for network vulnerabilities
func (s *VulnerabilityScannerService) scanNetwork() []Vulnerability {
	vulns := make([]Vulnerability, 0)

	// Check common dangerous ports (simplified check)
	dangerousPorts := []int{21, 23, 3389, 5432, 27017} // FTP, Telnet, RDP, PostgreSQL, MongoDB
	for _, port := range dangerousPorts {
		if s.isPortOpen("localhost", port) {
			vulns = append(vulns, Vulnerability{
				ID:          fmt.Sprintf("NET_%d_%d", time.Now().UnixNano(), port),
				Type:        VulnOpenPorts,
				Severity:    VulnSeverityMedium,
				Title:       fmt.Sprintf("Potentially Dangerous Port Open: %d", port),
				Description: fmt.Sprintf("Port %d is open on localhost", port),
				Remediation: "Review if this port needs to be open and restrict access",
				CVSS:        5.0,
				DetectedAt:  time.Now(),
				Status:      "OPEN",
			})
		}
	}

	return vulns
}

// isPortOpen checks if a port is open
func (s *VulnerabilityScannerService) isPortOpen(host string, port int) bool {
	address := fmt.Sprintf("%s:%d", host, port)
	conn, err := net.DialTimeout("tcp", address, 1*time.Second)
	if err != nil {
		return false
	}
	conn.Close()
	return true
}

// DetectSQLInjection checks input for SQL injection patterns
func (s *VulnerabilityScannerService) DetectSQLInjection(input string) (bool, string) {
	for _, pattern := range s.sqlPatterns {
		if pattern.MatchString(input) {
			return true, pattern.String()
		}
	}
	return false, ""
}

// DetectXSS checks input for XSS patterns
func (s *VulnerabilityScannerService) DetectXSS(input string) (bool, string) {
	for _, pattern := range s.xssPatterns {
		if pattern.MatchString(input) {
			return true, pattern.String()
		}
	}
	return false, ""
}

// ScanHTTPRequest scans an HTTP request for vulnerabilities
func (s *VulnerabilityScannerService) ScanHTTPRequest(r *http.Request) []Vulnerability {
	vulns := make([]Vulnerability, 0)

	// Scan URL parameters
	for key, values := range r.URL.Query() {
		for _, value := range values {
			if detected, pattern := s.DetectSQLInjection(value); detected {
				vulns = append(vulns, Vulnerability{
					ID:          fmt.Sprintf("REQ_%d", time.Now().UnixNano()),
					Type:        VulnSQLInjection,
					Severity:    VulnSeverityHigh,
					Title:       "SQL Injection in Query Parameter",
					Description: fmt.Sprintf("SQL injection pattern detected in parameter '%s'", key),
					Evidence:    fmt.Sprintf("Pattern: %s, Value: %s", pattern, value),
					DetectedAt:  time.Now(),
					Status:      "OPEN",
				})
			}

			if detected, pattern := s.DetectXSS(value); detected {
				vulns = append(vulns, Vulnerability{
					ID:          fmt.Sprintf("REQ_%d", time.Now().UnixNano()),
					Type:        VulnXSS,
					Severity:    VulnSeverityMedium,
					Title:       "XSS in Query Parameter",
					Description: fmt.Sprintf("XSS pattern detected in parameter '%s'", key),
					Evidence:    fmt.Sprintf("Pattern: %s, Value: %s", pattern, value),
					DetectedAt:  time.Now(),
					Status:      "OPEN",
				})
			}
		}
	}

	// Scan headers for suspicious values
	suspiciousHeaders := []string{"User-Agent", "Referer", "X-Forwarded-For"}
	for _, header := range suspiciousHeaders {
		value := r.Header.Get(header)
		if value != "" {
			if detected, _ := s.DetectSQLInjection(value); detected {
				vulns = append(vulns, Vulnerability{
					ID:          fmt.Sprintf("REQ_%d", time.Now().UnixNano()),
					Type:        VulnSQLInjection,
					Severity:    VulnSeverityMedium,
					Title:       "SQL Injection in Header",
					Description: fmt.Sprintf("SQL injection pattern detected in header '%s'", header),
					DetectedAt:  time.Now(),
					Status:      "OPEN",
				})
			}
		}
	}

	return vulns
}

// calculateSummary calculates vulnerability summary
func (s *VulnerabilityScannerService) calculateSummary(vulns []Vulnerability) VulnSummary {
	summary := VulnSummary{TotalVulnerabilities: len(vulns)}
	for _, v := range vulns {
		switch v.Severity {
		case VulnSeverityCritical:
			summary.CriticalCount++
		case VulnSeverityHigh:
			summary.HighCount++
		case VulnSeverityMedium:
			summary.MediumCount++
		case VulnSeverityLow:
			summary.LowCount++
		case VulnSeverityInfo:
			summary.InfoCount++
		}
	}
	return summary
}

// calculateRiskScore calculates overall risk score
func (s *VulnerabilityScannerService) calculateRiskScore(result *VulnerabilityScanResult) int {
	if len(result.Vulnerabilities) == 0 {
		return 0
	}

	// Weight-based scoring
	score := 0
	score += result.Summary.CriticalCount * 40
	score += result.Summary.HighCount * 25
	score += result.Summary.MediumCount * 10
	score += result.Summary.LowCount * 3
	score += result.Summary.InfoCount * 1

	if score > 100 {
		score = 100
	}

	return score
}

// determineRiskLevel determines risk level from score
func (s *VulnerabilityScannerService) determineRiskLevel(score int) string {
	if score >= 75 {
		return "CRITICAL"
	} else if score >= 50 {
		return "HIGH"
	} else if score >= 25 {
		return "MEDIUM"
	}
	return "LOW"
}

// generateRecommendations generates recommended actions
func (s *VulnerabilityScannerService) generateRecommendations(result *VulnerabilityScanResult) []string {
	recommendations := make([]string, 0)

	if result.Summary.CriticalCount > 0 {
		recommendations = append(recommendations, "‚ö†Ô∏è URGENT: Address critical vulnerabilities immediately")
	}

	// Type-specific recommendations
	typeCount := make(map[VulnerabilityType]int)
	for _, v := range result.Vulnerabilities {
		typeCount[v.Type]++
	}

	if typeCount[VulnMissingEncryption] > 0 {
		recommendations = append(recommendations, "Enable field-level encryption for sensitive data")
	}
	if typeCount[VulnBrokenAuth] > 0 {
		recommendations = append(recommendations, "Enforce MFA for all privileged accounts")
	}
	if typeCount[VulnSQLInjection] > 0 {
		recommendations = append(recommendations, "Review and strengthen input validation")
	}
	if typeCount[VulnBruteForce] > 0 {
		recommendations = append(recommendations, "Implement additional rate limiting measures")
	}
	if typeCount[VulnDataExposure] > 0 {
		recommendations = append(recommendations, "Run data migration to encrypt existing PII")
	}

	if len(recommendations) == 0 {
		recommendations = append(recommendations, "‚úÖ No immediate actions required")
	}

	return recommendations
}

// GetLastScan returns the last scan result
func (s *VulnerabilityScannerService) GetLastScan() *VulnerabilityScanResult {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.lastScan
}

// IsScanning returns whether a scan is in progress
func (s *VulnerabilityScannerService) IsScanning() bool {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.isScanning
}

// StartScheduler starts automated vulnerability scanning
func (s *VulnerabilityScannerService) StartScheduler(interval time.Duration) {
	s.mu.Lock()
	if s.schedulerCtx != nil {
		s.mu.Unlock()
		return
	}
	s.schedulerCtx, s.schedulerCancel = context.WithCancel(context.Background())
	s.mu.Unlock()

	go func() {
		ticker := time.NewTicker(interval)
		defer ticker.Stop()

		log.Printf("üîí Vulnerability Scanner Scheduler started (interval: %s)", interval)

		// Run initial scan
		if _, err := s.RunQuickScan(); err != nil {
			log.Printf("‚ùå Initial vulnerability scan failed: %v", err)
		}

		for {
			select {
			case <-s.schedulerCtx.Done():
				log.Println("üîí Vulnerability Scanner Scheduler stopped")
				return
			case <-ticker.C:
				if _, err := s.RunQuickScan(); err != nil {
					log.Printf("‚ùå Scheduled vulnerability scan failed: %v", err)
				}
			}
		}
	}()
}

// StopScheduler stops the vulnerability scanner scheduler
func (s *VulnerabilityScannerService) StopScheduler() {
	s.mu.Lock()
	defer s.mu.Unlock()

	if s.schedulerCancel != nil {
		s.schedulerCancel()
		s.schedulerCtx = nil
		s.schedulerCancel = nil
	}
}

// SanitizeInput sanitizes input string to prevent injection attacks
func SanitizeInput(input string) string {
	// Remove dangerous characters
	dangerous := []string{"'", "\"", ";", "--", "/*", "*/", "xp_", "0x"}
	result := input
	for _, d := range dangerous {
		result = strings.ReplaceAll(result, d, "")
	}
	return result
}
